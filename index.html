<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <!-- Viewport meta for proper mobile scaling -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>About Bruno</title>
    <style>
      @font-face {
        font-family: '8-bit Arcade In';
        src: url('assets/8-bit Arcade In.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      /* No scrollbars, full screen background */
      html, body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
      }
      /* The canvas is fixed at the design resolution */
      #gameCanvas {
        display: block;
        position: absolute;
        left: 0;
        top: 0;
        background: black;
      }
    </style>
  </head>
  <body>
    <!-- Canvas is set to design resolution (414x736) -->
    <canvas id="gameCanvas" width="414" height="736"></canvas>
    <script>
      //==================================================
      // CONFIGURATION: Tweak all key values here
      //==================================================
      const CONFIG = {
        designWidth: 414,         // Design resolution width (in design units)
        designHeight: 736,        // Design resolution height
        groundRatio: 0.8,         // Ground line is at 80% of design height
        physics: {
          gravity: 0.1,
          flapForce: -5,
          maxFallSpeed: 3
        },
        bird: {
          startX: 100,
          startY: 300,
          width: 120,
          height: 120,
          rotationUp: 20,
          rotationDown: 90,
          flapDuration: 300,  // Animation duration in milliseconds
          flapFrameTime: 50   // Time per frame in milliseconds
        },
        // Hitbox settings:
        hitboxes: {
          enabled: false,
          bird: {
            scale: 0.3,
            color: "red",
            lineWidth: 1
          },
          pipe: {
            color: "lime",
            lineWidth: 1
          },
          floor: {
            color: "blue",
            lineWidth: 2
          }
        },
        pipe: {
          spacing: 550,
          gap: 200,
          defaultWidth: 52,
          defaultHeight: 320,
          minEdgeDistance: 60,
          startingDistance: 600
        },
        speeds: {
          scrollSpeed: 1.5,
          bgScrollSpeed: 0.5
        },
        flash: {
          speed: 10,
          maxAlpha: 180
        },
        vita: {
          max: 12,
          scale: 0.6,
          fadeInSpeed: 0.01,
          fadeOutSpeed: 0.01,
          fadeDistance: 500
        },
        scoreFont: "78px '8-bit Arcade In'",
        scorePosition: {
          x: 0.5,
          y: 736 * 0.92
        },
        ui: {
          scale: 1.5,
          minMargin: 20,
          maxWidthPercent: 0.9,
          gameOver: {
            scale: 3.0,
            cooldownPeriod: 800,
            grid: {
              rows: 4,
              cols: 5,
              activeMinRow: 1,
              activeMaxRow: 3,
              activeMinCol: 1,
              activeMaxCol: 3
            }
          },
          pause: {
            buttonSize: 60,
            margin: 6,
            popupScale: 1
          }
        },
        ground: {
          overlap: 1
        }
      };

      //==================================================
      // GLOBALS & INITIAL SETUP
      //==================================================
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      ctx.imageSmoothingEnabled = false; // Disable smoothing for crisp, faster drawing

      // For our fixed-resolution canvas, worldWidth equals designWidth.
      let worldWidth = CONFIG.designWidth;
      const groundY = CONFIG.designHeight * CONFIG.groundRatio;

      // We'll use a CSS scale to enlarge the canvas to fill the viewport.
      function resizeCanvas() {
        const scale = Math.min(window.innerWidth / CONFIG.designWidth, window.innerHeight / CONFIG.designHeight);
        canvas.style.transformOrigin = "top left";
        canvas.style.transform = "scale(" + scale + ")";
        canvas.style.left = ((window.innerWidth - CONFIG.designWidth * scale) / 2) + "px";
        canvas.style.top = ((window.innerHeight - CONFIG.designHeight * scale) / 2) + "px";
      }
      window.addEventListener("resize", resizeCanvas);
      // Call once on load:
      resizeCanvas();

      let gameState = "menu"; // "menu", "play", "gameover"
      let score = 0;
      let pipes = [];
      let groundSegments = [];
      let vitaSprites = [];
      let bird = {
        x: CONFIG.bird.startX,
        y: CONFIG.bird.startY,
        width: CONFIG.bird.width,
        height: CONFIG.bird.height,
        vel: 0,
        rotation: 0,
        alive: true,
        grounded: false,
        spriteIndex: 0,
        frameTimer: 0
      };
      let birdFrames = [];
      let bgScroll = 0;
      let flashAlpha = 0;
      let vitaCounter = 0;
      let lastTime = 0;
      // Frame throttling: target 60 FPS
      let frameThrottle = 1000 / 60;
      let lastRenderTime = 0;
      let gameOverUI = { x: 0, y: 0, width: 0, height: 0, cellWidth: 0, cellHeight: 0 };
      let gamePaused = false;
      let pauseUI = { x: 0, y: 0, width: 0, height: 0, rowHeight: 0 };
      let gameOverTimer = 0;
      let flapStartTime = 0;
      let isFlapping = false;

      //==================================================
      // IMAGE LOADING
      //==================================================
      const imageList = [
        { name: "head_normal", src: "assets/head_normal.png" },
        { name: "head_1", src: "assets/head_1.png" },
        { name: "head_2", src: "assets/head_2.png" },
        { name: "head_3", src: "assets/head_3.png" },
        { name: "head_4", src: "assets/head_4.png" },
        { name: "pipe_top", src: "assets/pipe_top.png" },
        { name: "pipe_bottom", src: "assets/pipe_bottom.png" },
        { name: "ground", src: "assets/ground_new.png" },
        { name: "skyline", src: "assets/custom_skyline.png" },
        { name: "start", src: "assets/custom_start.png" },
        { name: "game_over", src: "assets/game_over.png" },
        { name: "tutorial", src: "assets/tutorial.png" },
        { name: "vita_1", src: "assets/vita_1.png" },
        { name: "vita_2", src: "assets/vita_2.png" },
        { name: "vita_3", src: "assets/vita_3.png" },
        { name: "vita_4", src: "assets/vita_4.png" },
        { name: "vita_5", src: "assets/vita_5.png" },
        { name: "vita_6", src: "assets/vita_6.png" },
        { name: "vita_7", src: "assets/vita_7.png" },
        { name: "vita_8", src: "assets/vita_8.png" },
        { name: "vita_9", src: "assets/vita_9.png" },
        { name: "vita_10", src: "assets/vita_10.png" },
        { name: "vita_11", src: "assets/vita_11.png" },
        { name: "vita_12", src: "assets/vita_12.png" },
        { name: "pause", src: "assets/pause.png" },
        { name: "pause_2", src: "assets/pause_2.png" }
      ];

      const ASSETS = {};

      function loadAllImages(list, callback) {
        let loadedCount = 0;
        list.forEach(item => {
          const img = new Image();
          img.src = item.src;
          img.onload = () => {
            ASSETS[item.name] = img;
            loadedCount++;
            if (loadedCount === list.length) callback();
          };
          img.onerror = () => {
            console.warn("Failed to load image:", item.src);
            loadedCount++;
            if (loadedCount === list.length) callback();
          };
        });
      }

      //==================================================
      // INITIAL SETUP AFTER IMAGES LOADED
      //==================================================
      function init() {
        // Set up bird animation frames:
        birdFrames = [
          ASSETS["head_normal"],
          ASSETS["head_1"],
          ASSETS["head_2"],
          ASSETS["head_3"],
          ASSETS["head_4"],
          ASSETS["head_normal"]
        ];
        resetGame();
        window.requestAnimationFrame(gameLoop);
      }

      function resetGame() {
        gameState = "menu";
        score = 0;
        flashAlpha = 0;
        bgScroll = 0;
        vitaCounter = 0;
        pipes = [];
        groundSegments = [];
        vitaSprites = [];
        bird.x = CONFIG.bird.startX;
        bird.y = CONFIG.bird.startY;
        bird.vel = 0;
        bird.alive = true;
        bird.grounded = false;
        bird.rotation = 0;
        bird.spriteIndex = 0;
        bird.frameTimer = 0;

        // Initialize ground segments
        let groundWidth = ASSETS["ground"] ? ASSETS["ground"].width : 640;
        const neededSegments = Math.ceil(worldWidth / groundWidth) + 4;
        for (let i = 0; i < neededSegments; i++) {
          groundSegments.push({
            x: i * (groundWidth - CONFIG.ground.overlap),
            y: groundY,
            width: groundWidth
          });
        }

        // Spawn initial pipes using fixed starting distance
        const initialX = CONFIG.pipe.startingDistance;
        let countPipes = Math.max(2, Math.ceil((worldWidth - initialX) / CONFIG.pipe.spacing) + 1);
        for (let i = 0; i < countPipes; i++) {
          spawnPipeSet(initialX + i * CONFIG.pipe.spacing);
        }
      }

      //==================================================
      // GAME LOOP WITH FRAME THROTTLING (60 FPS)
      //==================================================
      function gameLoop(timestamp) {
        let delta = timestamp - lastRenderTime;
        if (delta >= frameThrottle) {
          let dt = timestamp - lastTime;
          dt = Math.min(dt, 50); // cap dt
          lastTime = timestamp;
          update(dt);
          draw();
          lastRenderTime = timestamp;
        }
        window.requestAnimationFrame(gameLoop);
      }

      //==================================================
      // UPDATE LOGIC
      //==================================================
      function update(dt) {
        if (gamePaused) return;
        if (gameState === "menu") {
          vitaSprites.forEach(v => v.opacity = 0);
        } else if (gameState === "play") {
          bgScroll -= CONFIG.speeds.bgScrollSpeed;
          if (ASSETS["skyline"]) {
            let sw = ASSETS["skyline"].width;
            if (bgScroll <= -sw) bgScroll = 0;
          }
          updateBird();
          pipes.forEach(p => { p.x -= CONFIG.speeds.scrollSpeed; });
          pipes = pipes.filter(p => p.x + p.width > 0);
          let rightmost = pipes.length > 0 ? Math.max(...pipes.map(p => p.x)) : worldWidth * 0.75;
          if (rightmost < worldWidth) spawnPipeSet(rightmost + CONFIG.pipe.spacing);
          groundSegments.forEach(g => { g.x -= CONFIG.speeds.scrollSpeed; });
          groundSegments = groundSegments.filter(g => g.x + g.width > 0);
          let groundImgWidth = ASSETS["ground"] ? ASSETS["ground"].width : 640;
          let rightmostX = groundSegments.length > 0 ? Math.max(...groundSegments.map(g => g.x + g.width)) : 0;
          if (rightmostX < worldWidth + groundImgWidth) {
            groundSegments.push({
              x: rightmostX - CONFIG.ground.overlap,
              y: groundY,
              width: groundImgWidth
            });
          }
          vitaSprites.forEach(v => { v.x -= CONFIG.speeds.scrollSpeed; });
          vitaSprites = vitaSprites.filter(v => v.x + v.width > 0);
          vitaSprites.forEach(v => {
            const dx = v.x + v.width / 2 - bird.x;
            if (dx <= CONFIG.vita.fadeDistance && bird.alive) {
              v.opacity = Math.min(1, v.opacity + CONFIG.vita.fadeInSpeed);
            } else {
              v.opacity = Math.max(0, v.opacity - CONFIG.vita.fadeOutSpeed);
            }
          });
          checkCollisions();
        } else if (gameState === "gameover") {
          if (!bird.grounded) updateBird();
          vitaSprites.forEach(v => {
            v.opacity = Math.max(0, v.opacity - CONFIG.vita.fadeOutSpeed);
          });
        }
        if (flashAlpha > 0) flashAlpha = Math.max(0, flashAlpha - CONFIG.flash.speed);
      }

      function updateBird() {
        if (!bird.alive) {
          bird.vel += CONFIG.physics.gravity;
          if (bird.vel > CONFIG.physics.maxFallSpeed) bird.vel = CONFIG.physics.maxFallSpeed;
          bird.y += bird.vel;
          const hitboxHeight = bird.height * CONFIG.hitboxes.bird.scale;
          const visualOffset = (bird.height - hitboxHeight) / 2;
          if (bird.y + bird.height - visualOffset >= groundY) {
            bird.y = groundY - bird.height + visualOffset;
            bird.grounded = true;
          }
          return;
        }
        bird.vel += CONFIG.physics.gravity;
        if (bird.vel > CONFIG.physics.maxFallSpeed) bird.vel = CONFIG.physics.maxFallSpeed;
        bird.y += bird.vel;
        const hitboxHeight = bird.height * CONFIG.hitboxes.bird.scale;
        const visualOffset = (bird.height - hitboxHeight) / 2;
        if (bird.y + bird.height - visualOffset >= groundY) {
          bird.y = groundY - bird.height + visualOffset;
          bird.grounded = true;
          bird.alive = false;
          flashAlpha = CONFIG.flash.maxAlpha;
          endGame();
        }
      }

      function checkCollisions() {
        const hitboxWidth = bird.width * CONFIG.hitboxes.bird.scale;
        const hitboxHeight = bird.height * CONFIG.hitboxes.bird.scale;
        const hitboxX = bird.x + (bird.width - hitboxWidth) / 2;
        const hitboxY = bird.y + (bird.height - hitboxHeight) / 2;
        let birdHitbox = { x: hitboxX, y: hitboxY, width: hitboxWidth, height: hitboxHeight };
        for (let pipe of pipes) {
          if (rectOverlap(birdHitbox, pipe)) {
            if (bird.alive) {
              bird.alive = false;
              flashAlpha = CONFIG.flash.maxAlpha;
              endGame();
            }
            return;
          }
          if (!pipe.passed && pipe.type === "bottom") {
            if (bird.x > pipe.x) {
              pipe.passed = true;
              score++;
            }
          }
        }
        if (birdHitbox.y + birdHitbox.height >= groundY) {
          const visualOffset = (bird.height - hitboxHeight) / 2;
          bird.y = groundY - bird.height + visualOffset;
          bird.grounded = true;
          bird.alive = false;
          flashAlpha = CONFIG.flash.maxAlpha;
          endGame();
        }
      }

      function endGame() {
        gameState = "gameover";
        gameOverTimer = Date.now();
      }

      //==================================================
      // DRAWING (Using fixed design resolution)
      //==================================================
      function draw() {
        ctx.clearRect(0, 0, CONFIG.designWidth, CONFIG.designHeight);
        // Draw sky:
        ctx.fillStyle = "rgb(110,190,201)";
        ctx.fillRect(0, 0, worldWidth, groundY);
        // Draw ground:
        ctx.fillStyle = "rgb(221,216,157)";
        ctx.fillRect(0, groundY, worldWidth, CONFIG.designHeight - groundY);
        // Draw skyline:
        if (ASSETS["skyline"]) {
          let sw = ASSETS["skyline"].width;
          let sh = ASSETS["skyline"].height;
          let numTiles = Math.ceil(worldWidth / sw) + 2;
          for (let i = 0; i < numTiles; i++) {
            let xPos = i * sw + bgScroll;
            if (xPos < worldWidth && xPos > -sw) {
              ctx.drawImage(ASSETS["skyline"], xPos, groundY - sh);
            }
          }
        }
        // Draw pipes:
        pipes.forEach(p => {
          let img = (p.type === "top") ? ASSETS["pipe_top"] : ASSETS["pipe_bottom"];
          if (img) {
            ctx.drawImage(img, p.x, p.y);
          } else {
            ctx.fillStyle = "green";
            ctx.fillRect(p.x, p.y, p.width, p.height);
          }
        });
        // Draw ground segments:
        if (ASSETS["ground"]) {
          groundSegments.forEach(g => { ctx.drawImage(ASSETS["ground"], g.x, g.y); });
        } else {
          groundSegments.forEach(g => {
            ctx.fillStyle = "rgb(221,216,157)";
            ctx.fillRect(g.x, g.y, g.width, CONFIG.designHeight - g.y);
          });
        }
        // Draw vita sprites:
        vitaSprites.forEach(v => {
          if (v.img && v.opacity > 0) {
            ctx.save();
            ctx.globalAlpha = v.opacity;
            ctx.drawImage(v.img, v.x, v.y, v.width, v.height);
            ctx.restore();
          }
        });
        // Draw bird:
        drawBird();
        // Draw score:
        ctx.fillStyle = "#ffffff";
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 8;
        ctx.font = CONFIG.scoreFont;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.save();
        ctx.translate(worldWidth * CONFIG.scorePosition.x, CONFIG.scorePosition.y);
        ctx.scale(1, 1.5);
        ctx.strokeText(score.toString(), 0, 0);
        ctx.fillText(score.toString(), 0, 0);
        ctx.restore();
        // Draw flash effect:
        if (flashAlpha > 0) {
          ctx.fillStyle = `rgba(255,255,255,${flashAlpha / 255})`;
          ctx.fillRect(0, 0, worldWidth, CONFIG.designHeight);
        }
        // Draw menu or gameover UI:
        if (gameState === "menu") {
          drawMenu();
        } else if (gameState === "gameover") {
          drawGameOver();
        }
        // Draw pause button:
        if (gameState === "play" && !gamePaused) {
          const buttonSize = CONFIG.ui.pause.buttonSize;
          const margin = CONFIG.ui.pause.margin;
          if (ASSETS["pause"]) {
            ctx.drawImage(ASSETS["pause"], margin, margin, buttonSize, buttonSize);
          }
        }
        // Draw pause popup if paused:
        if (gamePaused && ASSETS["pause_2"]) {
          let img = ASSETS["pause_2"];
          let maxWidth = worldWidth * CONFIG.ui.maxWidthPercent;
          let scale = Math.min(
            CONFIG.ui.pause.popupScale,
            maxWidth / img.width,
            (CONFIG.designHeight * 0.8) / img.height
          );
          let scaledWidth = img.width * scale;
          let scaledHeight = img.height * scale;
          pauseUI.width = scaledWidth;
          pauseUI.height = scaledHeight;
          pauseUI.x = (worldWidth - scaledWidth) / 2;
          pauseUI.y = (CONFIG.designHeight - scaledHeight) / 2;
          pauseUI.rowHeight = scaledHeight / 3;
          ctx.fillStyle = "rgba(0,0,0,0.5)";
          ctx.fillRect(0, 0, worldWidth, CONFIG.designHeight);
          ctx.drawImage(ASSETS["pause_2"], pauseUI.x, pauseUI.y, scaledWidth, scaledHeight);
        }
        // Draw hitboxes if enabled:
        if (CONFIG.hitboxes.enabled) {
          const hitboxWidth = bird.width * CONFIG.hitboxes.bird.scale;
          const hitboxHeight = bird.height * CONFIG.hitboxes.bird.scale;
          const hitboxX = bird.x + (bird.width - hitboxWidth) / 2;
          const hitboxY = bird.y + (bird.height - hitboxHeight) / 2;
          ctx.strokeStyle = CONFIG.hitboxes.bird.color;
          ctx.lineWidth = CONFIG.hitboxes.bird.lineWidth;
          ctx.strokeRect(hitboxX, hitboxY, hitboxWidth, hitboxHeight);
          pipes.forEach(p => {
            ctx.strokeStyle = CONFIG.hitboxes.pipe.color;
            ctx.lineWidth = CONFIG.hitboxes.pipe.lineWidth;
            ctx.strokeRect(p.x, p.y, p.width, p.height);
          });
          ctx.strokeStyle = CONFIG.hitboxes.floor.color;
          ctx.lineWidth = CONFIG.hitboxes.floor.lineWidth;
          ctx.beginPath();
          ctx.moveTo(0, groundY);
          ctx.lineTo(worldWidth, groundY);
          ctx.stroke();
        }
      }

      function drawBird() {
        let frame = birdFrames[0];
        if (!frame) return;
        if (isFlapping) {
          const elapsed = Date.now() - flapStartTime;
          if (elapsed >= CONFIG.bird.flapDuration) {
            isFlapping = false;
          } else {
            const frameIndex = Math.floor(elapsed / CONFIG.bird.flapFrameTime) % birdFrames.length;
            frame = birdFrames[frameIndex];
          }
        }
        let angle = 0;
        if (!bird.alive) {
          angle = CONFIG.bird.rotationDown;
        } else if (bird.vel < 0) {
          angle = CONFIG.bird.rotationUp;
        }
        ctx.save();
        ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
        ctx.rotate((angle * Math.PI) / 180);
        ctx.drawImage(frame, -bird.width / 2, -bird.height / 2, bird.width, bird.height);
        ctx.restore();
      }

      function drawMenu() {
        if (ASSETS["start"]) {
          let img = ASSETS["start"];
          let maxWidth = worldWidth * CONFIG.ui.maxWidthPercent;
          let scale = Math.min(
            CONFIG.ui.scale,
            maxWidth / img.width,
            (CONFIG.designHeight * 0.4) / img.height
          );
          let scaledWidth = img.width * scale;
          let scaledHeight = img.height * scale;
          let x = (worldWidth - scaledWidth) / 2;
          let y = Math.max(CONFIG.ui.minMargin, CONFIG.designHeight * 0.2 - (scaledHeight / 2));
          ctx.drawImage(img, x, y, scaledWidth, scaledHeight);
        }
        if (ASSETS["tutorial"]) {
          let img = ASSETS["tutorial"];
          let x = bird.x + bird.width;
          let y = bird.y - (img.height / 4);
          ctx.drawImage(img, x, y, 105, 135);
        }
      }

      function drawGameOver() {
        if (ASSETS["game_over"]) {
          let img = ASSETS["game_over"];
          let maxWidth = worldWidth * CONFIG.ui.maxWidthPercent;
          let scale = Math.min(
            CONFIG.ui.gameOver.scale,
            maxWidth / img.width,
            (CONFIG.designHeight * 0.8) / img.height
          );
          let scaledWidth = img.width * scale;
          let scaledHeight = img.height * scale;
          gameOverUI.width = scaledWidth;
          gameOverUI.height = scaledHeight;
          gameOverUI.x = (worldWidth - scaledWidth) / 2;
          gameOverUI.y = (CONFIG.designHeight - scaledHeight) / 2;
          gameOverUI.cellWidth = scaledWidth / CONFIG.ui.gameOver.grid.cols;
          gameOverUI.cellHeight = scaledHeight / CONFIG.ui.gameOver.grid.rows;
          ctx.drawImage(img, gameOverUI.x, gameOverUI.y, scaledWidth, scaledHeight);
        }
      }

      //==================================================
      // EVENT HANDLERS
      //==================================================
      window.addEventListener("mousedown", handleInput);
      window.addEventListener("touchstart", (e) => {
        e.preventDefault();
        handleInput(e.touches[0]);
      });

      function handleInput(e) {
        let rect = canvas.getBoundingClientRect();
        // Convert coordinates relative to design resolution
        let clickX = (e.clientX - rect.left) / (parseFloat(canvas.style.transform.split('(')[1]) || 1);
        let clickY = (e.clientY - rect.top) / (parseFloat(canvas.style.transform.split('(')[1]) || 1);
        if (gameState !== "gameover" && !gamePaused) {
          const buttonSize = CONFIG.ui.pause.buttonSize;
          const margin = CONFIG.ui.pause.margin;
          if (clickX >= margin && clickX <= margin + buttonSize &&
              clickY >= margin && clickY <= margin + buttonSize) {
            gamePaused = true;
            return;
          }
        }
        if (gamePaused) {
          handlePauseClick(clickX, clickY);
          return;
        }
        if (gameState === "gameover") {
          handleGameOverClick(clickX, clickY);
        } else {
          handleJump();
        }
      }

      function handlePauseClick(clickX, clickY) {
        if (clickX >= pauseUI.x && clickX <= pauseUI.x + pauseUI.width &&
            clickY >= pauseUI.y && clickY <= pauseUI.y + pauseUI.height) {
          let relativeY = clickY - pauseUI.y;
          let rowIndex = Math.floor(relativeY / pauseUI.rowHeight);
          switch(rowIndex) {
            case 0:
              gamePaused = false;
              break;
            case 1:
              window.location.href = 'https://brunobrissa.com/about-play';
              break;
            case 2:
              window.location.href = 'https://brunobrissa.com';
              break;
          }
        }
      }

      function handleGameOverClick(clickX, clickY) {
        if (Date.now() - gameOverTimer < CONFIG.ui.gameOver.cooldownPeriod) return;
        if (clickX >= gameOverUI.x && clickX <= gameOverUI.x + gameOverUI.width &&
            clickY >= gameOverUI.y && clickY <= gameOverUI.y + gameOverUI.height) {
          let relativeX = clickX - gameOverUI.x;
          let relativeY = clickY - gameOverUI.y;
          let colIndex = Math.floor(relativeX / gameOverUI.cellWidth);
          let rowIndex = Math.floor(relativeY / gameOverUI.cellHeight);
          if (colIndex >= CONFIG.ui.gameOver.grid.activeMinCol &&
              colIndex <= CONFIG.ui.gameOver.grid.activeMaxCol &&
              rowIndex >= CONFIG.ui.gameOver.grid.activeMinRow &&
              rowIndex <= CONFIG.ui.gameOver.grid.activeMaxRow) {
            switch(rowIndex) {
              case 1:
                resetGame();
                break;
              case 2:
                window.location.href = 'https://brunobrissa.com/about';
                break;
              case 3:
                window.location.href = 'https://brunobrissa.com';
                break;
            }
          }
        }
      }

      function handleJump() {
        if (gameState === "menu") {
          gameState = "play";
          bird.vel = CONFIG.physics.flapForce;
          startFlapAnimation();
        } else if (gameState === "play" && bird.alive && !bird.grounded) {
          bird.vel = CONFIG.physics.flapForce;
          startFlapAnimation();
        }
      }

      function startFlapAnimation() {
        flapStartTime = Date.now();
        isFlapping = true;
      }

      //==================================================
      // PIPE & SPRITE SPAWNING
      //==================================================
      function spawnPipeSet(xPos) {
        const pipeHeight = ASSETS["pipe_top"]?.height || CONFIG.pipe.defaultHeight;
        const minCenter = CONFIG.pipe.minEdgeDistance + (CONFIG.pipe.gap / 2);
        const maxCenter = groundY - CONFIG.pipe.minEdgeDistance - (CONFIG.pipe.gap / 2);
        let gapCenter = Math.floor(Math.random() * (maxCenter - minCenter)) + minCenter;
        let topY = gapCenter - (CONFIG.pipe.gap / 2) - pipeHeight;
        let bottomY = gapCenter + (CONFIG.pipe.gap / 2);
        let topPipe = {
          x: xPos,
          y: topY,
          width: ASSETS["pipe_top"]?.width || CONFIG.pipe.defaultWidth,
          height: pipeHeight,
          type: "top",
          passed: false
        };
        let bottomPipe = {
          x: xPos,
          y: bottomY,
          width: ASSETS["pipe_bottom"]?.width || CONFIG.pipe.defaultWidth,
          height: pipeHeight,
          type: "bottom",
          passed: false
        };
        pipes.push(topPipe, bottomPipe);
        if (vitaCounter < CONFIG.vita.max) {
          let vitaName = `vita_${vitaCounter + 1}`;
          let vitaImg = ASSETS[vitaName];
          if (vitaImg) {
            let pipeWidth = topPipe.width;
            let nextPipeX = xPos + CONFIG.pipe.spacing;
            let midpointX = xPos + pipeWidth + (nextPipeX - (xPos + pipeWidth)) / 2;
            let vitaWidth = vitaImg.width * CONFIG.vita.scale;
            vitaSprites.push({
              x: midpointX - vitaWidth / 2,
              y: 55,
              width: vitaWidth,
              height: vitaImg.height * CONFIG.vita.scale,
              img: vitaImg,
              opacity: 0
            });
          }
          vitaCounter++;
        }
      }

      //==================================================
      // HELPER FUNCTION: Rectangle Overlap
      //==================================================
      function rectOverlap(r1, r2) {
        return !(
          r1.x + r1.width < r2.x ||
          r1.x > r2.x + r2.width ||
          r1.y + r1.height < r2.y ||
          r1.y > r2.y + r2.height
        );
      }

      //==================================================
      // START THE GAME
      //==================================================
      loadAllImages(imageList, () => {
        init();
      });

      document.addEventListener("visibilitychange", function() {
        if (document.hidden) {
          gamePaused = true;
        } else if (gameState !== "gameover") {
          gamePaused = false;
          lastTime = performance.now();
        }
      });
    </script>
  </body>
</html>
