<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>About Bruno - Phaser 3 Game</title>
    <style>
      /* Import your custom 8-bit font */
      @font-face {
        font-family: '8-bit Arcade In';
        src: url('assets/8-bit Arcade In.ttf') format('truetype');
        font-weight: normal;
        font-style: normal;
      }
      html, body {
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden;
      }
    </style>
    <!-- Include Phaser 3 from a CDN -->
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
  </head>
  <body>
    <script>
      /***************************************
       * CONFIGURATION (based on your original)
       ***************************************/
      const CONFIG = {
        designWidth: 414,
        designHeight: 736,
        groundRatio: 0.8, // Ground is at 80% of design height
        physics: {
          gravity: 300, // Gravity (Phaser uses pixel/sÂ²)
          flapForce: -200, // Upward velocity when flapping
          maxFallSpeed: 400
        },
        bird: {
          startX: 100,
          startY: 300,
          width: 120,
          height: 120,
          rotationUp: 20,
          rotationDown: 90,
          flapDuration: 300,
          flapFrameTime: 50
        },
        pipe: {
          spacing: 550,      // Horizontal spacing between pipes (design units)
          gap: 200,          // Vertical gap between top and bottom pipes
          defaultWidth: 52,
          defaultHeight: 320,
          minEdgeDistance: 60,
          startingDistance: 600
        },
        speeds: {
          scrollSpeed: 1.5,  // This value will be scaled into pixels in our code
          bgScrollSpeed: 0.5
        }
      };

      /***************************************
       * PHASER GAME CONFIGURATION
       ***************************************/
      const phaserConfig = {
        type: Phaser.AUTO,
        width: CONFIG.designWidth,
        height: CONFIG.designHeight,
        backgroundColor: 0x000000,
        parent: null,
        physics: {
          default: 'arcade',
          arcade: {
            gravity: { y: CONFIG.physics.gravity },
            debug: false
          }
        },
        scene: {
          preload: preload,
          create: create,
          update: update
        }
      };

      let game = new Phaser.Game(phaserConfig);

      /***************************************
       * GLOBAL GAME VARIABLES
       ***************************************/
      let gameState = "menu"; // "menu", "play", "gameover"
      let score = 0;
      let scoreText;
      let pipes;
      let ground;
      let bird;
      let pipeTimer = 0;
      let background;
      const groundY = CONFIG.designHeight * CONFIG.groundRatio;

      /***************************************
       * ASSET LOADING (ensure asset paths match your assets folder)
       ***************************************/
      function preload() {
        this.load.image('head_normal', 'assets/head_normal.png');
        this.load.image('head_1', 'assets/head_1.png');
        this.load.image('head_2', 'assets/head_2.png');
        this.load.image('head_3', 'assets/head_3.png');
        this.load.image('head_4', 'assets/head_4.png');
        this.load.image('pipe_top', 'assets/pipe_top.png');
        this.load.image('pipe_bottom', 'assets/pipe_bottom.png');
        this.load.image('ground', 'assets/ground_new.png');
        this.load.image('skyline', 'assets/custom_skyline.png');
        this.load.image('start', 'assets/custom_start.png');
        this.load.image('game_over', 'assets/game_over.png');
        this.load.image('tutorial', 'assets/tutorial.png');
        // (Additional assets like vita sprites can be added here)
      }

      /***************************************
       * SETUP FUNCTION
       ***************************************/
      function create() {
        // Create a tiled background for the skyline
        let skylineTexture = this.textures.get('skyline');
        background = this.add.tileSprite(0, groundY - skylineTexture.getSourceImage().height, CONFIG.designWidth, skylineTexture.getSourceImage().height, 'skyline');
        background.setOrigin(0, 0);

        // Create ground as a static group and fill the width
        ground = this.physics.add.staticGroup();
        let groundTexture = this.textures.get('ground');
        let groundWidth = groundTexture.getSourceImage().width;
        let segCount = Math.ceil(CONFIG.designWidth / groundWidth) + 2;
        for (let i = 0; i < segCount; i++) {
          let seg = ground.create(i * (groundWidth - CONFIG.ground.overlap), groundY, 'ground');
          seg.setOrigin(0, 0);
        }

        // Create pipes group
        pipes = this.physics.add.group();

        // Create the bird sprite; here we simply use "head_normal" as a placeholder.
        // (You can extend this later to animate through frames if desired.)
        bird = this.physics.add.sprite(CONFIG.bird.startX, CONFIG.bird.startY, 'head_normal');
        bird.setDisplaySize(CONFIG.bird.width, CONFIG.bird.height);
        bird.setCollideWorldBounds(true);
        bird.body.allowGravity = false; // We'll enable gravity when game starts

        // Add collision between bird and ground
        this.physics.add.collider(bird, ground, hitGround, null, this);

        // Display score text
        scoreText = this.add.text(10, 10, 'Score: 0', { font: "32px Arial", fill: "#ffffff" });

        // Input handling: pointer down will trigger the flap or start/restart the game
        this.input.on('pointerdown', onPointerDown, this);
      }

      /***************************************
       * GAME UPDATE FUNCTION
       ***************************************/
      function update(time, delta) {
        if (gameState === "play") {
          // Enable gravity for the bird
          if (!bird.body.allowGravity) {
            bird.body.allowGravity = true;
          }

          // Bird physics (gravity is handled by Arcade physics)
          // (You can add rotation based on velocity if desired)
          if (bird.body.velocity.y < 0) {
            bird.angle = -CONFIG.bird.rotationUp;
          } else {
            bird.angle = CONFIG.bird.rotationDown;
          }

          // Scroll the skyline background
          background.tilePositionX += CONFIG.speeds.bgScrollSpeed * delta;

          // Pipe logic: remove offscreen pipes and spawn new ones
          pipes.getChildren().forEach(pipe => {
            if (pipe.x + pipe.width < 0) {
              pipes.remove(pipe, true, true);
              score += 0.5; // Each pipe pair gives 1 point in total
              scoreText.setText('Score: ' + Math.floor(score));
            }
          });
          if (time - pipeTimer > 2000) { // spawn new pipes every 2 seconds
            spawnPipePair(this);
            pipeTimer = time;
          }

          // Check if bird has hit the bottom (missed ground)
          if (bird.y + bird.height/2 >= CONFIG.designHeight) {
            gameState = "gameover";
            endGame(this);
          }
        } else if (gameState === "gameover") {
          // Stop the game: you could show a game over screen here
          this.physics.pause();
        }
      }

      /***************************************
       * PIPE SPAWNING FUNCTIONS
       ***************************************/
      function spawnPipePair(scene) {
        let gap = CONFIG.pipe.gap;
        let pipeTopTexture = scene.textures.get('pipe_top');
        let pipeBottomTexture = scene.textures.get('pipe_bottom');
        let pipeHeight = pipeTopTexture.getSourceImage().height;
        let minCenter = CONFIG.pipe.minEdgeDistance + gap / 2;
        let maxCenter = groundY - CONFIG.pipe.minEdgeDistance - gap / 2;
        let gapCenter = Phaser.Math.Between(minCenter, maxCenter);
        let topY = gapCenter - gap/2 - pipeHeight;
        let bottomY = gapCenter + gap/2;
        // Create top pipe
        let topPipe = scene.physics.add.sprite(CONFIG.designWidth, topY, 'pipe_top');
        topPipe.setDisplaySize(CONFIG.pipe.defaultWidth, pipeHeight);
        topPipe.body.allowGravity = false;
        topPipe.setVelocityX(-CONFIG.speeds.scrollSpeed * 100);
        // Create bottom pipe
        let bottomPipe = scene.physics.add.sprite(CONFIG.designWidth, bottomY, 'pipe_bottom');
        bottomPipe.setDisplaySize(CONFIG.pipe.defaultWidth, pipeHeight);
        bottomPipe.body.allowGravity = false;
        bottomPipe.setVelocityX(-CONFIG.speeds.scrollSpeed * 100);
        pipes.add(topPipe);
        pipes.add(bottomPipe);
        // Add collision between bird and pipes
        scene.physics.add.overlap(bird, pipes, hitPipe, null, scene);
      }

      function hitPipe() {
        gameState = "gameover";
      }

      function hitGround() {
        gameState = "gameover";
      }

      /***************************************
       * INPUT HANDLING
       ***************************************/
      function onPointerDown() {
        if (gameState === "menu") {
          gameState = "play";
          bird.body.allowGravity = true;
          bird.setVelocityY(CONFIG.physics.flapForce);
          // Reset pipe timer
          pipeTimer = 0;
        } else if (gameState === "play") {
          bird.setVelocityY(CONFIG.physics.flapForce);
        } else if (gameState === "gameover") {
          // Restart the scene
          this.scene.restart();
          gameState = "menu";
          score = 0;
        }
      }

      /***************************************
       * END GAME FUNCTION
       ***************************************/
      function endGame(scene) {
        // You can add a game over screen or restart logic here.
        // For now, we simply pause physics.
        scene.physics.pause();
      }
    </script>
  </body>
</html>
